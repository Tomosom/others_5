# 页式内存管理

- 段式内存管理回顾
    - 这里的 "段" 具体指什么？
        - 一段连续的内存空间
    - 为什么会有段式内存管理？
        - 程序的各个部分相对独立（如：数据段，代码段）
        - 早期 x86 处理器无法通过一个寄存器访问所有内存单元
        - 解决早期程序运行时的重定位问题

- 段式内存管理的应用
    - 在 x86 系列的处理器中，硬件对段式内存管理进行了直接支持
    - 另外，段式内存管理也可使用纯软件实现
    - 核心：段首地址 + 段内偏移地址 = 内存单元地址

- 段式内存管理在C语言中的体现
    - 数组的本质：一片连续的内存（段）
    - 数组名 (array) : 数组的起始内存地址（段地址)
    - 数组元素的访问 : array[i] ⇔ *(array + i)
    - 第 i 个元素的地址：
        ![](_v_images_/.png)

- 思考
    操作系统中只使用段式内存管理是否足够?

- 软硬件技术的发展
    - 硬件技术
        - 计算机部件独立化（硬件接口相同，可任意组装）
        - 计算机配置差异化（各部件硬件参数不同，如：内存容量）
    - 软件技术
        - 应用程序处理的问题越来越复杂（解决实际问题）
        - 应用程序运行需要的资源越来越多（物理内存可能无法满足）

- 问题
    应用程序规模越来越大，导致多数时候无法全部加载进入内存，如何解决？

- 可行的解决方案：按段加载（局部性原理)
    - 只将当前程序运行需要的段加载进内存
    - 当某个段不再需要使用，立即从内存中移除

- 按段加载可能带来的问题
    - 段的大小不确定，可能大于实际的物理内存
    - 段加载时需要具体的长度信息，导致效率不高
    - ...

- 更进一步的解决方案：内存分页
    - 页指的是固定大小的内存片（4KB)
    - 每一个内存段由多个页组成
    - 页是进行内存管理的基本单位（加载页，换出页)

- 段页式内存管理
    ![](_v_images_/.png)

- 生活中的 "段页式" 应用
    大多数情况下，书都采用 "段页式" 的方法进行内容编排。
    ![](_v_images_/.png)

# 实例分析 分页应用实例

- 进阶虚拟存储技术
    - 实模式下所使用的是什么地址空间？
    - 保护模式下所使用的是什么地址空间？
    - 如何分离不同应用程序所使用的内存空间？
    - 程序运行需要的内存大于实际物理内存该怎么办?

- 进阶虚拟存储技术（内存分页的意义）
    - 虚拟内存空间（逻辑地址）：
        - 程序执行时内部所使用的内存空间（独立于其它程序)
    - 物理内存空间（物理地址）：
        - 物理机器所配置的实际内存空间（所有程序共享）
    - 逻辑地址需要进行转换才能得到对应的物理地址

- 页式内存管理中的地址
    - 地址 = 页号 + 页内偏移
        - 逻辑地址 = 逻辑页号 + 页内偏移
        - 物理地址 = 物理页号 + 页内偏移
        - 地址转换时仅变更页号即可，页内偏移不变

- 逻辑地址到物理地址的映射（重定位）
    ![](_v_images_/.png)

- 页式内存管理中的关键操作一
    - 页请求
        - 访问一个逻辑地址时，对应的页不在内存中
            √ 从外存中将目标页加到内存中
            √ 之后更新页表

- 页式内存管理中的关键操作二
    - 页交换
        - 页请求时发现物理内存不足，需要将暂时不用的页移除
            √ 首先，决定并选择需要移除的页
            √ 将选中页中的所有数据写入外存
            √ 更新页表，重新进行页请求

    ![](_v_images_/.png)

# 小结
- 内存分段能够解决一定问题，但无法保证程序的移植性
- 根据程序运行的局部性原理，可进一步对内存进行分页
- 页指的是固定大小的内存片（4KB)
- 页的引入使得程序的逻辑地址与内存的物理地址彻底分离
- 操作系统的内存管理是以页为基本单位完成的
