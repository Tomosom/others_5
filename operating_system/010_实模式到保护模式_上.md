# 实模式到保护模式

- 从计算机的历史谈起
    - 远古时期的程序开发：直接操作物理内存
    - CPU指令的操作数直接使用实地址（实际内存地址)
    - 程序员拥有绝对的权利（利用CPU指哪打哪）

- 绝对的权利带来的问题
    - 难以重定位
        - 程序每次都需要同样地址的内存执行
    - 绐多道程序设计带来障碍
        - 不管内存多大，但凡一个字节被其它程序占用都无法执行

- CPU历史的里程碑-8086
    - 地址线宽度为20位，可访问1M内存空间
    - 引入 [段地址：偏移地址] 的内存访问方式
        - 8086的段寄存器和通用寄存器为16位
        - 单个寄存器寻址最多访问64K的内存空间
        - 需要两个寄存器配合，完成所有内存空间的访问

- 深入解析[段地址：偏移地址]
    - 硬件所做的工作
        - 段地址左移4位，构成20位的基地址（起始地址）
        - 基地址+偏移地址=实地址
    - 对于开发者的意义
        - 更有效的划分内存的功能（数据段，代码段，等）
        - 当出现程序地址冲突时，通过修改段地址解决冲突

- 示例

```x86asm
mov ax, [0x1234]       ;实地址：（ds << 4) + 0x1234
mov ax, [es:0xl234]    ;实地址：（es << 4) + 0x1234
```

- 有趣的问题
    [段地址：偏移地址]能访问的最大地址为OxFFFF : OxFFFF ,
    即：10FFEF ; 超过了 1MB 的空间，CPU如何处理？

- 8086中的高端地址区（High Memory Area )
     ![](_v_images_/.png)

- 8086的处理方式
    由于8086只有20位地址线，因此最高位被丟弃（溢出）！
    ![](_v_images_/.png)

- 再谈8086历史
    - 8086在当时是非常成功的一款产品
    - 因此，拥有一大批的开发者和应用程序
    - 各种基于8086程序设计的技术得到了发展
    - 不幸的是，各种奇技淫巧也应运而生
    - ......

- 8086时期应用程序中的问题
    - 1MB内存完全不够用（内存在任彳可时期都不够用）
    - 开发者在程序中大量使用内存回卷技术（HMA地址被使用）
    - 应用程序之间没有界限，相互之间随意干扰
        - A程序可以随意访问B程序中的数据
        - C程序可以修改系统调度程序的指令

- 思考
    8086程序中问题的本质是什么？
    如果是你，准备如何解决？

- 80286的登场
    - 8086已经有那么多应用程序了，所以必须兼容再兼容
    - 加大内存容量，増加地址线数量（24位）
    - [段地址：偏移地址] 的方式可以强化一下
        - 为每个段提供更多属性（如：范围，特权级，等）
        - 为每个段的定义提供固定方式

- 80286的兼容性
    - 默认情况下完全兼容8086的运行方式（实模式)
        - 默认可直接访问 1MB 的内存空间
        - 通过特殊的方式访问 1MB+ 的内存空间

- 这个特殊的方式指的是什么？？ ？
    80286之后的工作模式

    |               实模式               |            保护模式             |
    | --------------------------------- | ------------------------------ |
    | 兼容8086的工作模式                  | 新的工作模式                     |
    | 实地址 = (段寄存器 << 4) + 偏移地址 | 内存地址 = 段起始地址 + 偏移地址  |
    | 任意内存随意访问                    | 每个段增加各种属性描述, 保证安全性 |

- 初识保护模式
    - 每一段内存的拥有一个属性定义（描述符Descriptor)
    - 所有段的属性定义构成—张表（描述符表Descriptor Table )
    - 段寄存器保存的是属性定义在表中的索引（选择子Selector)
    - ......

- 描述符 (Descriptor) 的内存结构
    ![](_v_images_/.png)

- 描述符表 (Descriptor Table)
    ![](_v_images_/.png)

- 选择子 (Selector) 的结构
    ![](_v_images_/.png)
    - 说明：
        - RPL
            - 请求者特权级标i只，通过特权级判断是否可以访问对应段
        - TI
            - 表示当前选择子所属的描述符表（0 - GDT, 1 - LDT )

- 进入保护模式的方式
    1. 定义描述符表
    2. 打开 A20 地址线
    3. 加载描述表
    4. 通知 CPU 进入保护模式

# 小结
- [段地址 : 偏移地址] 的寻址方式解决了早期程序重定位难的问题
- 8086 实模式下的程序无法保证安全性
- 80286 中提出了保护模式，加强了内存段的安全性
- 出于兼容性的考虑，80286之后的处理器都有 2 种工作模式
- 处理器需要特定的设置步骤才能进入保护模式，默认为实模式

