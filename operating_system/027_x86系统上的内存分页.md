# x86系统上的内存分页
-  x86系列处理器上的页式内存管理
    - 硬件层直接支持内存分页机制
    - 默认情况下不使用分页机制（段式内存管理）
    - 分页机制启动后，使用二级页表对内存进行管理

- x86系列处理器的分页方式（32位）
    ![](_v_images_/.png)

- x86分页机制示意图
    ![](_v_images_/.png)

-  x86系列处理器的分页方式（32位）
    - 页目录大小
        - 2^10^项，每项4字节，共计2^10^ * 4 = 2^12^ ⇒ 4K
    - 子页表大小
        - 2^10^项，每项4字节，共计2^10^ * 4 = 2^12^ ⇒ 4K
    - 页大小
        - 2^12^ 字节 ⇒ 4K

- —些重要结论（针对32位x86处理器）
    - 页目录占用1内存页（可访问1024个子页表）
    - 单个子页表占用1内存页（可访问1024个页面）
    - 页面起始地址按4K字节对齐（总是4096整数倍）
    - 分页后可访问的虚拟内存空间为：4K * (1024 * 1024) = 4G

- 最简单的分页构建方式
    ![](_v_images_/.png)

- x86系列处理器上的页属性
    - 由于物理页面的地址必须按照 4K 字节对齐
    - 因此，页目录（页表）可使用地址的低12位进行属性描述

    ![](_v_images_/.png)

-  x86系列处理器上的页属性


|  位  | 标记  |        说明        |
| ---- | ----- | ------------------ |
| 0    | P     | 页面是否存在于内存中 |
| 1    | R/W   | 页面是否可读可写     |
| 2    | U/S   | 页面特权级说明      |
| 3    | PWT   | 页面缓冲策略        |
| 4    | PCD   | 页面是否可以被缓冲   |
| 5    | A     | 页面是否可访问      |
| 6    | D/R   | 页面是否被写入标记   |
| 7    | PS    | 页面单位标记        |
| 8    | G     | 全局页面标记        |
| 9…11 | Avail | 预留给系统编程使用   |

- x86对分页的硬件支持
    - 将 cr3 指向页目录地址（可切换不同的页目录)
    - 将 cr0 最高位置1 (硬件级开启分页机制）

        ```x86asm
        mov eax, PageDirBase
        mov cr3, eax
        mov eax, cr0
        or  eax, 0x80000000
        mov cr0, eax
        ```

- 汇编小贴士一
    - loop
        - 循环指令，将 cx 减1, 若 cx 不为0, 则执行标签处代码

        ```x86asm
        mov ax, 0
        mov cx, 10

        Label:
            add ax, cx
            loop Label
        ```

- 汇编小贴士二
    - stosb / stosw / stosd
        - 把 al / ax / eax 中的值存储到 edi 指向的内存单元中
        - 同时 edi 的值根据方向标志增加或者减少（cld / std)

        ```x86asm
        mov es, ax
        mov edi, 0
        mov eax, 0xFF
        cld
        stosd
        ; [es : 0] ⇒ 0xFF
        ; edi ⇒ 4
        ```

# 编程实验 x86处理器上的分页实现

# 小结
-  x86 处理器直接支持内存分页机制（默认关闭）
-  分页机制启动后，使用二级页表对内存进行管理
-  页目录和单个子页表占用 1 内存页（4K内存）
-  页面起始地址按 4K 字节对齐
-  分页后可访问的虚拟内存空间为 4G
