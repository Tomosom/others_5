# 实战页式内存管理
- 课后疑问
    PageTable类的本质是一维数组，那么，为什么PCB类中的页表成员不直接使用一维数组?

- 设计准则
    ![](_v_images_/.png)
    - 根据程序运行的局部性原理
        - 多数情况下，页表为稀疏状态
        - 单级页表会浪费大量内存资源
    - 二级页表
        - 把页号分为两段：页目录 + 二级页号
        - 如果下级页表的所有表项为空，那么页目录为空

- 课程设计目标：二级页表设计
    ![](_v_images_/.png)

- 具体设计
    - 由于最大页号为0xFF, 因此
        - 页目录大小为( 0xF + 1 )
        - 子页表大小为( 0xF + 1 )
    - 页访问时将页号分解为两部分
        - 高位部分访问页目录
        - 低位部分访问下级页表

    ```c
    int* m_pt[PAGE_DIR_NUM];
    // ..........................
    // access page i

    int dir = ((i & 0xF0) >> 4);
    int spn = (i & 0x0F);

    if( m_pt[dir] == NULL ) {
        m_pt[dir] = new int[PAGE_SUB_NUM];

        for(int k = 0; k < PAGE_SUB_Nm; k++) {
            m_pt[dir][k] = FP_NONE;
        }
    }

    return m_pt[dir][spn];
    ```

# 编程实验 二级页表的实现 PageEx

# 小结
- 在实现上，页框表，页表和任务结构是相互关联的关系
- 页框分配和页框回收时需要斩断页框表和页表的双向关联
- 任务结构是任务的内在表示，包含了私有的页表
-  FIFO 和 LRU 页交换算法都是从概率的角度选择页面移除
- 在设计上，将未来可能出现的代码变动封装到局部
- 多级页表的设计需要先对页号进行合理分割
