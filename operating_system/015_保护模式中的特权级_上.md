# 保护模式中的特权级
- 保护模式小结
    - 使用选择子访问段描述符表时，索引值的合法性检测
        - 当索引值越界时，引发异常
        - 判断规则：索引值* 8 + 7 < =段描述表界限值

        ![](_v_images_/.png)

- 保护模式小结
    - 内存段类型合法性检测
        - 具备可执行属性的段（代码段）只能加载到CS寄存器
        - 具备可写属性的段（数据段）才能加载到SS寄存器
        - 具备可读属性的段才能加载到DS, ES, FS, GS寄存器

- 保护模式小结
    - 代码段和数据段的保护
        - 处理器每访问_^地址都要确认该地址不超过界限值
        - 判断规则：
            - 代码段：IP +指令长度 <=代码段界限
            - 数据段：访问起始地址+访问数据长度 <=数据段界限

            ![](_v_images_/.png)

- 注意
    保护模式中代码中定义的界限值通常为：
    最大偏移地址值（相对于段基地址)

# 实例分析 保护模式小结

- 问题
    保护模式除了利用段界限对内存访问进行保护, 是否还提供其它的保护机制？

- 保护模式中的特权级
    - X86架构中的保护模式提供了 4个特权级（0, 1, 2, 3 )
    - 特权级从高到底分别是0, 1, 2, 3 (数字越大特权级越低）

    ![](_v_images_/.png)

- 特权级的表现形式
    - CPL (Current Privilege Level)
        - 当前可执行代码段的恃权级，由CS寄存器最低2位定义
    - DPL (Descriptor Privilege Level)
        - 内存段的特权级，在段描述符表中定义
    - RPL (Request Privilege Level)
        - 选择子的特权级，由选择子最低2位定义

- 初探特权级
    ![](_v_images_/.png)
    段描述符中的DPL用于标i只内存段的特权级；可执行代码访问内存段时必须满足一定恃权级（CPL ),否则，处理器将产生异常。

- CPL和DPL的关系
    - 保护模式中，每一尤码段都定义了一^ DPL
    - 当处理器从A代码段成功瑕赌到B代码段执行
        - 跳转之前：<font color=red>CPL = DPL~A~</font>
        - 跳转之后：<font color=blue>CPL = DPL~B~</font>

- CPL 和 DPL的关系
    - 保护模式中，每一个数据段都定义了一个 DPL
    - 当处理器执行过程中需要访问数据段时：
        CPL<= DPL~data~

- 段描述符中的 DPL 常量定义

|  标识符  | 常量值 |  意义   |
| ------- | ----- | ------- |
| DA_DPL0 | 0x00  | DPL = 0 |
| DA_DPL1 | 0x20  | DPL = 1 |
| DA_DPL2 | 0x40  | DPL = 2 |
| DA_DPL3 | 0x60  | DPL = 3 |

# 编程实验 保护模式特权级初探

- 实验结论
    - 处理器进入保护模式后CPL = 0 (最高特权级）
    - 处理器不能直接从高特权级转换到底特权级执行
    - 选择子 RPL 大于对应段描述符的 DPL 时，产生异常

- 引出的问题
    - 如何在不同特权级的代码段之间遇啭执行？
    - 高特权级代码为什么不能使用低特权级栈段？
    - 选择子的RPL具体有什么用？
    To be continued ...

# 小结
- 保护模式对内存的访问范围有严格定义
- 保护模式定义了内存段的特权级（0, 1, 2, 3 )
    - 每个内存段都有固定的特权级 (DPL)
    - 不同代码段之间成功跳转后 CPL 可能发生改变
    - CPL 小于或等于数据段 DPL 才能成功访问数据
