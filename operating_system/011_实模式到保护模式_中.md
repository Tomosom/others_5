# 实模式到保护模式
- 80286的光荣退场
    - 历史意义
        - 引入了保护模式，为现代操作系统和应用程序奠定了基础
    - 奇葩设计
        - 段寄存器为24位，通用寄存器为16位（不伦不类)
            - 理论上，段寄存器中的数值可IU直接作为段基址
            - 16位通用寄存器最多访问64K的内存
            - 为了访问16M内存，必须不停切换段基址

- 80386的登场（计算机新时期的标志）
    - 32位地址总线（可支持4G的内存空间）
    - 段寄存器和通用寄存器都为32位
        - 任何一个寄存器都能访问到内存的任意角落
            - 开启了平坦内存模式的新时代
            - 段基址为0, 使用通用寄存器访问4G内存空间

- 新时期的内存使用方式
    - 实模式
        - 兼容8086的内存使用方式（指哪打哪）
    - 分段模式
        - 通过[段地址：偏移地址]的方式将内存从功能上分段（數据段，代码段）
    - 平坦模式
        - 所有内存就是一个段[0 : 32位偏移地址]

- 有趣的问题
    x86指的究竟是什么处理器？

- 段属性定义

    |  标识符  |   值   |        意义        |
    | ------- | ------ | ------------------ |
    | DA_32   | 0x4000 | 保护模式下32位段    |
    | DA_DR   | 0x90   | 只读数据段          |
    | DA_DRW  | 0x92   | 可读写数据段        |
    | DA_DRWA | 0x93   | 已访问可读写数据段   |
    | DA_C    | 0x98   | 只执行代码段        |
    | DA_CR   | 0x9A   | 可执行可读代码段     |
    | DA_CCO  | 0x9C   | 只执行一致代码段     |
    | DA_CCOR | 0x9E   | 可执行可读一致代码段 |

- 选择子属性定义
    ![](_v_images_/.png)

- 保护模式中的段定义

```x86asm
%macro Descriptor 3                         ;段基址，段界限，段属性
    dw %2 & 0XFFFF                          ;段界限1
    dw %1 & 0xFFFF                          ;段基址1
    db (%1 >> 16) & 0xFF                    ;段基址2
    dw ((%2 >> 8) & 0xF00) | (%3 & 0XF0FF)  ;属性1 + 段界限2 + 属性2
    db (%1 >> 24) & 0xFF                    ;段基址3
%endmacro                                   ;共8字节
```
![](_v_images_/.png)

- 保护模式中的段定义

```x86asm
; GDT 定义
;                              段基址,    段界限,              属性
GDT_ENTR : Descriptor          0,        0,                   0
C0DE32_DES : Descriptor        0,        SegCodeB2Len - 1,    DA_C + DA—32
; ......

GdtLen               equ     $ - GDT_ENTRY ; GDT长度
GdtPtr:
                     dw      GdtLen - 1    ; GDT界限
                     dd      0             ; GDT基地址，需要重新计算
```

- 汇编小贴士
    - section 关键字用于 "逻辑的" 定义一段代码集合
    - section 定义的代码段不同于 [段地址：偏移地址] 的代码段
        - section定义的代码段仅限于源码中的代码段（代码节）
        - [段地址：偏移地址] 的代码段指内存中的代码段

        ![](_v_images_/.png)


- 汇编小贴士
    - [bits 16]
        - 用于指示编译器将代码按照16位方式进行编译
    - [bits 32]
        - 用于指示编译器将代码按照32位方式进行编译

- 注意事项
    - 段描述表中的第0个描述符不使用（仅用于占位）
    - 代码中必须显示的指明 16 位代码段和 32 位代码段
    - 必须使用 jmp 指令从 16 位代码段跳转到 32 位代码段

# 编程实验 保护模式 编程初体验

- 问题
    为什么不直接使用标签定义描述符中的段基地址 ？
    为什么16位代码段到32位代码段必须无条件跳转 ？

- 需要掌握的重点
    - NASM将汇编文件当成一个独立的代码段编译
    - 汇编代码中的标签 (Label) 代表的是段内偏移地址
    - 实模式下需要配合段寄存器中的值计算标签的物理地址

- 小知识
    - 流水线技术
        - 处理器为了提高效率将当前指令和后续指令预取到流水线
        - 因此，可能同时预取的指令中既有16位代码又有32位代码
        - 为了避免将32位代码用16位的方式运行，需要刷新流水线
        - 无条件跳转 jmp 能强制刷新流水线
        - ...

# 小结
- 80386处理器是计算机发展史上的里程碑
- 32位的寄存器和地址总线能够直接访问4G内存的任意角落
- 需要在16位实模式中对GDT中的数据进行初始化
- 代码中需要为 GDT 定义一个标识数据结构（GdtPtr)
- 需要使用 jmp 指令从16位代码跳转到 32 位代码
