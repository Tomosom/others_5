# 页式内存管理
- 页式内存管理需要注意的问题
    - 操作系统如何管理实际的物理内存？
    - 页表与不同任务（App)有怎样的关系?
    - 页表对于任务（App)的意义是什么？
    - 页交换时如何选择需要替换的内存页？
    - 页表具体是如何构成的？

- 操作系统如何管理实际的物理内存？
    - 页框与页面（Frame and Page)
        - 页框（Frame) : 物理内存空间中的页（物理页)
        - 页面（Page) : 逻辑内存空间中的页（逻辑页）
    > 页框用于存储页面的内容, 而页面内容来源于逻辑内存空间

- 操作系统对物理内存的管理
    - 操作系统必须知道物理内存的使用情况
        - 建立结构对物理内存进行管理（FrameTable)
        - 结构记录包括：页框是否可用，被谁使用，等
        - 为具体的应用程序分配页表

- 操作系统对物理内存的管理（方式之一)
    ![](_v_images_/.png)
    任务表：
        操作系统实现多任务（App) 的关数据结构 ,用于记录各个任务的上下文信息。

- 页表与不同任务（App)有怎样的关系?
    - 每个任务都有专属的页表
    - 页表是任务上下文的一部分

    ![](_v_images_/.png)

- 页表对于任务（App)的意义是什么？
    - 页表机制能够保证任务无法意外的访问或破坏其它任务的内存
    - 页表是虚拟内存空间与物理内存空间的 "分界线"
    - 因为页表的存在，各个任务才具备相同且独立的内存空间
    - 页表是虚拟内存通往物理内存的 "唯一通道"

    ![](_v_images_/.png)
    > 任务只能在页表机制下间接访问分配的物理内存，因此无丨去5付其它内存进行1访问。

- 页交换时如何选择需要替换的内存页？
    - 原则：挑选不再使用的内存页进行替换
        - FIFO 页交换算法
            - 将最先进入内存的页移出
        - LRU 页交换算法
            - 将当前使用最少的页从内存中移出

- FIFO页交换算法原理
    ![](_v_images_/.png)

- LRU页交换算法原理
    - 核心思想：
        - 如果某个页在最近一段时间内没有被访问到，那么在未来一段时间内被访问到的概率很小。

- LRU页交换算法原理
    ![](_v_images_/.png)

- LRU页交换算法原理
    - 访问计数的更新方式
        - 每个时间周期 (Interval) 将所有页框的访问计数减1
        - 当某个页面被访问时 (RW) 将访问计数加1
        - 访问计数最小的页面是最近未被使用的页

- 页表具体是如何构成的？
    - 页表的本质是一个映射表
    - 虚拟内存空间中的每一页映射到一个页框
    - 页表可以看作做一维整型数组（单级页表)

- 单级页表
    - 每个任务（App)都有页表
    - 单级页表大小固定（占用固定内存)
    - 根据程序运行的局部性原理：
        - 多数情况下，页表为稀疏状态
        - 单级页表会浪费大量内存资源

        ![](_v_images_/.png)

- 二级页表
    - 把页号分为两段：页目录 + 二级页号
    - 如果下级页表的所有表项为空，那么页目录为空

    ![](_v_images_/.png)

- 二级页表示例
    - 假设当前需要访问虚拟页为0x52,贝U:页目录为0x5, 二级页号为0x2。所以：对应的页框号为0x31。

    ![](_v_images_/.png)

# 小结
- 操作系统通过页框表对物理内存进行管理（分配与回收）
- 每个任务都有自己专属的页表，任务通过页表使用物理内存
- 需要页置换时，通过规则选择短期内不再使用的页进行置换
- 单级页表能够快速映射对应的页框，但造成内存浪费
- 二级页表将页号分为两部分：页目录 + 二级页号
- 二级页表需要通过一次寻址才能映射到对应的页框
