# 保护模式中的特权级
- 问题
    如何在不同特权级的代码段之间辦专执行？

- —种新的描述符：门描述符（Gate Descriptor)
    - 通过门描述符在不同特权级的代码间进行跳转
    - 根据应用场景的不同，门描述符分为：
        - 调用门（Call Gates )
        - 中断门（Interrupt Gate )
        - 陷阱门（Trap Gate )
        - 任务门（Task Gate )

- 门描述符的内存结构
    - 每一个门描述符占用8字节内存
    - 不同类型门描述的内存含义不同

    ![](_v_images_/.png)

- 调用门描述符（Call Gates ) 的定义
    ![](_v_images_/.png)

```x86asm
%macro Gate 4
    dw (%2 & 0XFFFF)                       ; 偏移地址1
    dw %1                                  ; 选择子
    dw (%3 & 0xlF) | ((%4 << 8) & 0XFF00)  ; 属性
    dw ((%2 >> 16) & 0XFFFF)                ; 偏移地址2
%endmacro
```

- 调用门描述符的工作原理
    ![](_v_images_/.png)

- 调用门描述符的使用
    ![](_v_images_/.png)

- 调用门描述符的使用
    ![](_v_images_/.png)

- 汇编小贴士
    - 汇编语言中的跳转方式
        - 段内跳转：call, jmp
            - 参数为相对地址，函數调用时只需要保存当前偏移地址
        - 段间跳转：call far, jmp far
            - 参数为选择子和偏移地址
            - 函数调用时需要同时保存段基地址和偏移地址

# 编程实验 初探调用门

- 实验结论
    - 门描述符是一种特殊的的描述符，需要注册于段描述符表
    - 调用门可以看作一个函数指针（保存具体函数的入口地址）
    - 通过调用门选择子对相应的函数进行远调用（call far)
    - 可以直接使用 选择子 : 偏移地址 的方式调用其它段的函数
    - 使用调用门时偏移地址无意义，仅仅是语法需要（为什么？）

- 历史遗留问题
    保护模式下的不同段之间如何进行代码复用 (如：调用同一个函数）？

- 解决方案
    - 将不同代码段需要复用的函数定义到独立的段中（retf)
    - 计算每一个可复用函数的偏移量（FuncName - $$ )
    - 通过 段选择子 : 偏移地址 的方式对目标函数进行远调用

# 编程实验 解决历史遗留问题

# 小结
- 门描述符是一种特殊的描述符，需要注册于段描述符表
- 门描述符分为：调用门，中断门，陷阱门，任务门
- 调用门可以看作一个函数指针（保存具体函数的入口地址）
- 调用门选择子对应的函数调用方式为远调用（call far)
