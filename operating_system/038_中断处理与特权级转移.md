# 中断处理与特权级转移
- 问题
       8259A在中断特殊完全嵌套方式下，同一个
       弓丨脚的新中断是否可以打断日中断的处理？

- 问题剖析
            IR0         INTR
      时钟中断
                 主      INTA
                 8259A                             CPU
                                    TYPE       N\
                        ---------------------
                        --------------------- ^
      假设：时钟中断请求周期为5ms ,对应的中断服务程序执行时间
      为10ms ;那么，中断服务程序是否会被新的时钟中断请求打断?

- 关于中断优先级
    _中断优先级由8259A管理（高优先级中断请求优先送往处理器）
     -处理器决定是否响应中断请求（处理器没有中断优先级的概念）
     -在默认情况下
          •中断服务程序执行时，屏蔽外部中断请求（IF ==0)
          •中断服务程序返回后，重新响应外部中断（IF ==1)

- 中断嵌套
           如果希望高优先级中断请求打断当前中断服务程序，可以
          在中断服务程序中打开丨F , 即 ： 将 IF设置为1 ( sti )。

# 实例分析 中断嵌套条件的分析

- 当代操作系统的设计
    -应用程序（DPL3)执行系统调用时会陷入内核态（DPL0)
    -自定义软中断用于系统调用（int 0x80)
    -通过软中断陷入内核态以最高特权级（DPL0)执行系统调用
    -中断服务程序运行于内鶴（DPL0)

- 与调用门类似
                 如果中断发生时涉及特权级转移，那么必
                      须为不同特权级准备不同的栈。

- 中断特权级转移过程
     1 •处理器通过中断向量找到对应的中断描述符
     2. 特权级检查：
          •软中断：（目标代码段DPL <= CPL) && (CPL <=中断描述符DPL)
          •外部中断：CPL> =目标代码段DPL
     3. 加载目标代码段选择子到CS, 加载偏移地址到ip

- 中断发生时的压栈
          Stack_DPL3                  Stack_DPL0
                      ifunc equ i0x80func - $$

- 中断服务程序返回
    - iret使得处理器从内核态返回用户态
    -返回时进行特权级检查
             • CPL<=目标代码段DPL (高特权级+低特权级）
             •对相关段寄存器强制清零（指向高特权级数据的段寄存器）

- 中断结束时的栈恢复
                      ;DPL3
                         「secion .codel
                cs                                      CODE SEGMENT:
                        push ax
                     push bx
         int 0x80
 ;DPL0
 [secion . x x ]
 INT_SEGMENT:
 i0x80func:
 iret
 ifunc equ i0x80func - $$

-  eflags标志寄存器
31 30 20 28 27 26 2S 24 23 22 21 20 10 18 17 16 1S 14 13 12 11 10 0 8 7 6 5 4 3 2 1 0
      X 翁D Rag <ID)----------------------------------------------
      X Virtual Interrupt Pending (VIP)-----------------
      X Virtual Interrupt Flag (VIF)------------------------------
      X Alignment Check / Access Control ( A C ) —
      X Wtual^086 Mode (VM)------------------------------------------
      X Resume Flag (RF)

      AX Nested Task (NT)--------------------------------------------------
          t/O Privilege Level (IOPL)------------------------------------

      £ Overflow Flag (OF)-----------------------------------------------
           Direction Flag (DF)-----------------------------------------------
      X Interrupt Enable Flag (IF)-------------------------------------
     Trap Flag (TF)---------------------------------------------------------

      As Sign Flag (SF)--------------------------------------------------------

      s Zero Flag (ZF)--------------------------------------------------------
      s Auxiliary Carry Rag (AF)---------------------------------------
      s Parity Rag (PF)------------------------------------------------------
      s Carry Flag (CF)-------------------------------------------------------

      S Indicates a Status Rag                       IA-32 32-Bit EFLAGS Register
      C Indicates a Control Flag
      X Indicates a System Flag

      □ Reserved bit positions. DO NOT USE.
              Always set to values previously read.

-  eflags标志寄存器
    _ IF:系统标志位，决定是否响应外部中断
          • IF == 1,响应外咅P中断
          • IF==〇,屏蔽外部中断
    -IOPL:系统标志位，决定是否允许进行丨〇操作
          • CPL <= l〇PL才能允许访问丨◦端口
          •当且仅当CPL = = 0时才能改变丨〇PL的值

- 设置IOPL的方法
    x86汇编语言没有提供指令改变eflags寄存器的值,
    因此，只能利用pushf和popf指令间接改变。
                      pushf                          ;eflags的值压入栈中
                      pop eax                        ;eflags的值保存到eax
                      or eax^ 0x3000                 ;eax中的第12, 1 3 位 置 1
                      push eax                       ;eax的值压入栈中
                      popf                           ，•将eflags中的IOPL设 置 为 3

# 实例分析 中断处理时的特权级转移

- 目标实验：使用软中断实现系统调用
     1 •定义32位核心代码段（中断函数，系统函数）
     2•定义32位任务代码段和数据段（用户程序）
     3 . 通 过 软 中 断 （int 0x80)转移到内核态调用系统函数（低+高）
    4•在任务代码段使用软中断（int0x80)实现功能函数

- 目标实验
                                  return far         DPL = 0
                                                      核心
                                                     代码段
                        int 0x80              mmm\-  DPL = 0
                            系统函数
                               iret
                用户态                                                                 内核态

- 注意事项
    -将I0PL设置为3使得用户态和内核态均可访问丨〇端口
    -特权级转移时会发生栈的变换（定义丁SS结构，定义不同栈段）
    -在用户态通过Sti指令使得处理器响应外部中断（必须用户态）

-  0x80中断设计（系统调用设计）
    一ax == 〇:夕卜部设备中断初始化（InitDevInt)
    一ax = = 1 : 字 符 串 打 印 （ Printf)
    一ax = = 2 : 启 动 时 钟 中 断 （ EnableTimer)

# 编程实验 软中断实现系统调用

# 小节
- 处理器执行中断服务程序期间不再响应新中断（IF = = 0 )
- 如果需要进行中断嵌套，使用sti设置丨F标志位（丨F = = 1)
-  I0PL决定是否允许进行丨〇操作，CPL<=I〇PL才能访问丨〇端口
- 使用中瞧行特权级转换（低+高）
      -软中断：（目标代码段DPL <= CPL) && (CPL <=中断描述符DPL)
      - 外 部 中 断 ：CPL > =目标代码段DPL
