# 突破 512 字节的限制

- 突破限制的预备工作
    ![](_v_images_/.png)

- 整体思路
    ![](_v_images_/.png)

- 问题
    如何在根目录区中查找目标文件？

- 通过根目录项的前11个字节进行判断

```c
int d = fn.lastlndexOf(".");
QString name = QString(re.DIR_Name).trimmed();

if( d >= 0 ) {
    QString n = fn.mid(0, d);
    QString p = fn.mid(d + 1);

    if( name.startsWith(n) && name.endsWith(p) ) {
        ret = re;
        break;
    }
} else {
    if( fn == name ) {
        ret = re;
        break;
    }
}
```

- 内存比较
    - 指定源起始地址（DS : SI)
    - 指定目标起始地址（ES : DI)
    - 判断在期望长度（CX )内每一个字节是否都相等

    ![](_v_images_/.png)

- 汇编小贴士
    - 汇编中的比较与跳转
        - 比较：
            ```x86asm
            cmp cx, 0   ;比较 cx 的值是否为0
            ```
        - 跳转：
            ```x86asm
            jz equal    ;如果比较的结果为真，则跳转到 equal 标签处
            ```

- 汇编小贴士
    ![](_v_images_/.png)

# 编程实验 内存比较函数 MemCmp

- 查找根目录区是否存在目标文件
    ![](_v_images_/.png)

- 加载根目录区

```x86asm
mov ax, 19      ; 从第19逻辑扇区开始
mov cx, 14      ; 连续读取14个扇区
mov bx, Buf      ; 读取至 Buf 中

call ReadSector
```

- 汇编小贴士
    - 访问栈空间中的栈顶数据
        - 不能使用 sp 直接访问桟顶数据
        - 通过其它通用寄存器间接访问栈顶数据

        ```x86asm
        push cx
        mov bp, sp
        ; ......
        mov cx, [bp] ; ERROR --> mov cx, [sp]
        ; ......
        ```

# 编程实验 根目录区查找函数 FindEntry

# 小结
- 可通过查找根目录区判断是否存在目标文件
    - 加载根目录区至内存中（ReadSector)
    - 遍历根目录区中的每一项（FindEntry)
    - 通过每一项的前11个字节进行判断（MemCmp)
    - 当目标不存在时，打印错误信息（Print)
