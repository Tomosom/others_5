# 突破 512 字节的限制

- 突破限制的预备工作(两个功能函数)
![](_v_images_006/1.png)

# 创建字符串打印函数
- 问题
    主引导程序中<font color=red>如何进行字符串打印</font>？
    > 前面的程序, 是利用了字符的打印来实现字符串打印, 并没有一次性打印一个字符串, 是通过循环的方式将字符串中的数据逐个打印出来实现的
    > 要实现一次性打印,需利用BIOS中的中断

- BIOS中的字符串打印
    - 指定打印参数 ( <font color=red>AX = 0x1301, BX = 0x0007</font> )
        > 规定
    - 指定字符串的内存地址 ( <font color=#d0d>ES:BP = 串地址</font> )
        > 按段地址以及段内偏移地址的方式来指定目标字符串的内存地址
        > 前面讲过: 在汇编语言中, 使用过段地址加上段内偏移地址的方式来确定最终的内存地址的
    - 指定字符串的长度 ( <font color=#d00>CX = 串长度</font> )
    - 中断调用 ( <font color=blue>int 0x10</font> )

- 字符串打印示例

    ```x86asm
    ; 指定字符串地址
    mov ax, msg    ; 字符串在内存中的位置, msg:代表字符串在内存中某个段内的偏移地址
    mov bp, ax     ; 再赋给 bp
    mov ax, ds     ; 指定段地址. 为什么不直接 mov es, ds ???
    mov es, ax     ; 在这个示例中,我们的目标字符串在 es 段中

    ; 指定字符串长度
    mov cx, 6

    ; 指定打印参数
    mov ax, 0x1301
    mov bx, 0x0007

    int 0x10
    ```

- 汇编小贴士
    - 汇编中可以定义函数（函数名使用<font color=blue>标签</font>定义）
        - `call function` (调用函数, function : 函数的入口地址)
        - 函数体的最后—条指令为 <font color=blue>ret</font> (返回指令)
    - 如果代码中定义了函数，那么需要定义栈空间
        - <font color=#d0d>用于保存关键寄存器的值</font>
        - 栈顶地址通过 <font color=red>sp</font> 寄存器保存
        > 下面编程看到
    - 汇编中的 "常量定义" (<font color=blue>equ</font>)
        - 用法：`Const equ 0x7c00    ;#define Const 0x7c00`
        > Const 就是汇编语言中的一个符号, equ 表示要将这个符号定义为一个常量值
        - 与 <font color=red>dx</font> (<font color=blue>db, dw, dd</font>)的区别：
            - <font color=red>dx</font> 定义占用相应的内存空间
            - <font color=blue>equ</font> 定义<font color=red>不会占用</font>任何内存空间
            > 可理解为 C语言中定义变量与定义宏之间的差异

# [<u>编程实验 定义打印函数 print</u>](code/006_突破512字节的限制_上)
1. 创建makefile简化工作
    > 编写主引导程序的代码, 编译, 得到二进制文件(OUT), 创建虚拟软盘文件, 将主引导程序二进制代码烧写到虚拟软盘的第0个扇区, 然后才能到 bochs 中运行.

```makefile
.PHONY : all clean rebuild

SRC := boot.asm
OUT := boot.bin
IMG := data.img

RM := rm -fr

all : $(OUT) $(IMG)
	dd if=$(OUT) of=$(IMG) bs=512 count=1 conv=notrunc
	@echo "Success!"

$(IMG) :
	bximage $@ -q -fd -size=1.44

$(OUT) : $(SRC)
	nasm $^ -o $@

clean :
	$(RM) $(IMG) $(OUT)

rebuild :
	@$(MAKE) clean
	@$(MAKE) all
```

2. 编写主引导程序汇编代码 : boot_v1.asm
    执行: bochs -> 6 -> c[ontinue] : (未做清屏操作, 所以是如下打印)
    ![](_v_images_006/e1.png)

3. 优化主引导程序的汇编代码, 封装print函数 : boot_v2.asm
    打印定义的整个字符串
    ![](_v_images_006/e2.png)

# 软盘读取
- 问题
    主引导程序中<font color=red>如何读取指定扇区处的数据</font>？

- 软盘的构造
    - 一个软盘有2个盘面，每个盘面对应1个磁头
    - 每一个盘面被划分为若干个圆圏，成为柱面（磁道）
    - 每一个柱面被划分为若干个扇区，每个扇区512字节

    ![](_v_images_006/2.png)

- 3.5寸软盘的数据特性
    - 每个盘面一共80个拄面 (编号为0 - 79)
    - 每个拄面有18个扇区 (编号为1 - 18)
    - 存储大小：
        2 * 80 * 18 * 512 = 1474560 Bytes = 1440 KB
        > 2个盘面, 80个柱面, 18个扇区, 512字节
- 软盘数据的读取(如何定位我们感兴趣的扇区?)
    > 前面所使用的扇区号是`逻辑扇区号`, 逻辑扇区号是线性的, 从0开始逐步增大的. 在真正的软盘物理结构上, 不是这样线性编号, 是以下面的三元组来编号的
    - 软盘数据以扇区（<font color=red>512字节</font>）为单位进行读取
    - 指定数据所在位置的<font color=blue>磁头号，拄面号，扇区号</font>
    - 计算公式：
    ![](_v_images_006/3.png)
    > 柱面扇区数是18, 得到的余数是物理扇区号, 商和1相与就是磁头号(总共就两个磁头)

- BIOS中的软盘数据读取 (int 0x13)
    ![](_v_images_006/4.png)
    > 读数据时, AH寄存器的值是0x02, 这是规定好的

- 软盘数据读取流程
    ![](_v_images_006/5.png)


- 汇编小贴士
    - 汇编中的<font color=red>16位</font>除法操作（div )
        - 被除数放到 AX 寄存器
        - 除数放到通用寄存器或内存单元（因为是16位除法, 所以除数必须是<font color=red>8位</font>）
        - 结果：<font color=red>商位于AL, 余数位于 AH</font>

# [<u>编程实验 磁盘数据的读取</u>](code/006_突破512字节的限制_上)(boot_v3.asm)
1. 编写重置软驱函数 ResetFloppy

```x86asm
; 重置软驱
; no parameter
ResetFloppy:
    push ax ; 在栈中备份
    push dx

    mov ah, 0x00
    mov dl, [BS_DrvNum] ; DL寄存器:当前的燃区号, BS_DrvNum:在fat12文件系统的头信息中定义了软驱的编号
    int 0x13

    pop dx ; 出栈与进栈的顺序要相反
    pop ax

    ret
```

2. 编写读取软驱数据的函数 ReadSector

```x86asm
; 读取软驱数据
; ax    --> logic sector number
; cx    --> number of sector
; es:bx --> target address
ReadSector:
    push bx
    push cx
    push dx
    push ax

    call ResetFloppy

    push bx ; 下面修改了bx寄存器的值, 意味着目标内存的地址被改变了. 因此此处压栈保存, 此处遗漏可反汇编调试
    push cx

    mov bl, [BPB_SecPerTrk] ; 除数:18, 每个柱面所拥有的扇区数
    div bl ; 商在al, 余数在ah
    mov cl, ah
    add cl, 1 ; 扇区号
    mov ch, al
    shr ch, 1 ; 柱面号
    mov dh, al
    and dh, 1 ; 磁头号
    mov dl, [BS_DrvNum] ; 驱动器号:A盘

    pop ax ; 将cx寄存器的值出栈, 放到ax寄存器中, 这样ax中就有了我们要读取的扇区的数量
    pop bx

    mov ah, 0x02 ; 读的时候ah = 0x02, 这是规定好的

read:
    int 0x13
    jc read ; 执行0x13号中断的时候有可能读取失败. 若错误标志位被设置, 则跳转重读

    pop ax
    pop dx
    pop cx
    pop bx

    ret
```

3. 进行测试
    3.1 使用上节制作的 [<u>data.img</u>](code/005_master_boot_extend_2/Fat12Test) , 在windows中用 notepad++ 以十六进制方式打开, 找到之前写入虚拟软盘的文件的内容. 我们来做测试读取里边的字符串
    ![](_v_images_006/e3.png)
    确定这个字符串位于哪个扇区 : 22016(0x5600) / 512 = 43, 即,位于第43扇区的第0字节处.

    3.2 实验运行
    ```
    1. cd 006_突破512字节的限制_上
    2. 更改makefile, 汇编源码改为 : boot_v3.asm
    3. make clean
    4. cp ../005_master_boot_extend_2/Fat12Test/data.img .
    5. make
    6. 运行bochs
    ```
    > copy2个扇区, 打印1000个字节的实验结果 (红框为原有的系统的打印)
    > ![](_v_images_006/e4.png)

    3.3 汇编代码的调试手段
    上面的 ReadSector, 在计算 扇区号, 柱面号, 磁头号等信息时, 若未保存bx寄存器, 导致打印异常, 该如何调试?
    ```x86asm
    ; 读取软驱数据
    ; ax    --> logic sector number
    ; cx    --> number of sector
    ; es:bx --> target address
    ReadSector:
        push bx
        push cx
        push dx
        push ax

        call ResetFloppy

        ;push bx ; 下面修改了bx寄存器的值, 意味着目标内存的地址被改变了. 因此此处压栈保存, 此处遗漏可反汇编调试
        push cx

        mov bl, [BPB_SecPerTrk] ; 除数:18, 每个柱面所拥有的扇区数
        div bl ; 商在al, 余数在ah
        mov cl, ah
        add cl, 1 ; 扇区号
        mov ch, al
        shr ch, 1 ; 柱面号
        mov dh, al
        and dh, 1 ; 磁头号
        mov dl, [BS_DrvNum] ; 驱动器号:A盘

        pop ax ; 将cx寄存器的值出栈, 放到ax寄存器中, 这样ax中就有了我们要读取的扇区的数量
        ;pop bx

        mov ah, 0x02 ; 读的时候ah = 0x02, 这是规定好的

    read:
        int 0x13
        jc read ; 执行0x13号中断的时候有可能读取失败. 若错误标志位被设置, 则跳转重读

        pop ax
        pop dx
        pop cx
        pop bx

        ret
    ```

# 小结
- 当汇编代码中定义了函数，那么也需要定义栈空间
- 读取数据前，<font color=#d0d>逻辑扇区号需要转化为磁盘的物理位置</font>
- 物理软盘上的数据位置由<font color=blue>磁头号，柱面号，扇区号</font>唯一确定
- 软盘数据以扇区（<font color=red>512字节</font>）为单位进行读取
