# 恃权级与内核安全示例
- 问题
    既然通常情况下选择子中的RPL与对应描述符中的DPL相同，那么是否可以取缔RPL ?

- 答案
    RPL是保证内核数据安全的关键要素之一; 在内核代码中有决定性作用，绝对不能取缔！

-  一 个生活中的例子。。。
    如果是你，你会用什么方法拿到核心代码？
    ![](_v_images_/.png)

- 解决方案
    ![](_v_images_/.png)

- 计算机中的相似情形
    用户程序想要访问获取操作系统内核中的私密数据!
    ![](_v_images_/.png)

# 编程实验 内核私密数据的获取

- 初步解决方案：
    - 获取段寄存器中 RPL 的值
    - 判断 RPL 的值是否为SA_RPL0
        - true - 检查通过，可继续访问数据
        - false - 特权级较低，触发异常

- 代码流程
    ![](_v_images_/.png)

- 小技巧 - 通过下标为0的描述符触发异常
    ![](_v_images_/.png)

# 编程实验 内核私密数据的获取 初步解决方案

- 当前方案存在的问题
    用户程序可以通过 "伪造" 选择子中的 RPL 值, 从而绕开安全检查的机制（CheckRPL )。

- 解决思路：追踪真实的请求者
    1. 在栈中获取函数远调用前 CS 寄存器的值（请求者）
    2. 从之前 CS 寄存器的值中获取 RPL~cr~ (请求者特权级）
    3. 用 RPL~cr~ 更新到数据缓冲区对应的段寄存器中
    4. 使用 CheckRPL 对段寄存器进行安全检查

- 追踪真实的请求者
    ![](_v_images_/.png)

# 编程实验 内核私密数据的获取 最终解决方案

# 小结
- RPL 是保证内核数据安全的关键要素之一
- 内核代码可通过追踪真实请求者特权级判断操作合法性
- 但凡进行函数远调用，真实请求者的选择子就会存储于栈中
- 通过提取真实特权级 (RPL) 能够保证内核数据安全
